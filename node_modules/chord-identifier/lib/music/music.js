"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chord = exports.createNoteFromName = exports.Note = exports.Pitch = exports.Interval = void 0;
var Interval;
(function (Interval) {
    Interval[Interval["UNISON"] = 0] = "UNISON";
    Interval[Interval["MINOR_SECOND"] = 1] = "MINOR_SECOND";
    Interval[Interval["MAJOR_SECOND"] = 2] = "MAJOR_SECOND";
    Interval[Interval["MINOR_THIRD"] = 3] = "MINOR_THIRD";
    Interval[Interval["MAJOR_THIRD"] = 4] = "MAJOR_THIRD";
    Interval[Interval["PERFECT_FOURTH"] = 5] = "PERFECT_FOURTH";
    Interval[Interval["TRITONE"] = 6] = "TRITONE";
    Interval[Interval["PERFECT_FIFTH"] = 7] = "PERFECT_FIFTH";
    Interval[Interval["MINOR_SIXTH"] = 8] = "MINOR_SIXTH";
    Interval[Interval["MAJOR_SIXTH"] = 9] = "MAJOR_SIXTH";
    Interval[Interval["MINOR_SEVENTH"] = 10] = "MINOR_SEVENTH";
    Interval[Interval["MAJOR_SEVENTH"] = 11] = "MAJOR_SEVENTH";
})(Interval = exports.Interval || (exports.Interval = {}));
var Pitch;
(function (Pitch) {
    Pitch[Pitch["C"] = 0] = "C";
    Pitch[Pitch["Cs"] = 1] = "Cs";
    Pitch[Pitch["D"] = 2] = "D";
    Pitch[Pitch["Ds"] = 3] = "Ds";
    Pitch[Pitch["E"] = 4] = "E";
    Pitch[Pitch["F"] = 5] = "F";
    Pitch[Pitch["Fs"] = 6] = "Fs";
    Pitch[Pitch["G"] = 7] = "G";
    Pitch[Pitch["Gs"] = 8] = "Gs";
    Pitch[Pitch["A"] = 9] = "A";
    Pitch[Pitch["As"] = 10] = "As";
    Pitch[Pitch["B"] = 11] = "B";
})(Pitch = exports.Pitch || (exports.Pitch = {}));
class Note {
    constructor(pitch, octave) {
        this._pitch = pitch;
        this._octave = octave;
    }
    get pitch() {
        return this._pitch;
    }
    get octave() {
        return this._octave;
    }
    equals(other) {
        return this.pitch === other.pitch && this.octave === other.octave;
    }
    toString() {
        return Pitch[this.pitch].replace('s', '#') + this.octave;
    }
    getSemitoneValue() {
        return 12 * this.octave + this.pitch;
    }
    compare(other) {
        if (this.getSemitoneValue() < other.getSemitoneValue())
            return -1;
        if (this.getSemitoneValue() > other.getSemitoneValue())
            return 1;
        return 0;
    }
    getInterval(relativeNote) {
        const semitoneDistance = relativeNote.pitch - this.pitch;
        return semitoneDistance < 0 ? semitoneDistance + 12 : semitoneDistance;
    }
}
exports.Note = Note;
exports.createNoteFromName = (noteName) => {
    noteName = noteName.trim();
    const splitIndex = noteName.includes('#') || noteName.includes('b') ? 2 : 1;
    const octave = Number(noteName.slice(splitIndex));
    const getPitchOffsetValue = (pitchName) => {
        if (pitchName.length === 1)
            return 0;
        if (pitchName.charAt(1) === '#')
            return 1;
        if (pitchName.charAt(1) === 'b')
            return -1;
        throw new Error('Error: note cannot be determined from name.');
    };
    const offset = getPitchOffsetValue(noteName.slice(0, splitIndex));
    const noteBase = noteName.charAt(0);
    if (!Object.values(Pitch).includes(noteBase))
        throw new Error('Error: note cannot be determined from name.');
    let pitchValue = Pitch[noteBase] + offset;
    if (pitchValue === 12)
        pitchValue = 0;
    if (pitchValue === -1)
        pitchValue = 11;
    const pitch = pitchValue;
    return new Note(pitch, octave);
};
class Chord {
    constructor(root, bass, intervals) {
        this.sortNoteNames = (first, second) => {
            if (first[0] === 'b' || second[0] === '#' || first === '7')
                return -1;
            if (first[0] === '#' || second[0] === 'b' || first === 'maj7')
                return 1;
            throw new Error('Error: invalid note name labels');
        };
        this._root = root;
        this._bass = bass;
        this._intervals = intervals ?? new Set();
        this._name = Pitch[root.pitch];
        this._prob = 0;
        this.determineChordName();
    }
    get prob() {
        return this._prob;
    }
    toString() {
        return this._name;
    }
    addNewInterval(interval) {
        this._intervals.add(interval);
        this.determineChordName();
    }
    fillExtensionNotes(remainingNotes) {
        while (remainingNotes.size > 0) {
            const lowestInterval = Math.min(...remainingNotes.keys());
            const labels = remainingNotes.get(lowestInterval) ?? [];
            remainingNotes.delete(lowestInterval);
            switch (labels.length) {
                case (3):
                case (2):
                    let tempName = [...'add('];
                    labels
                        .sort(this.sortNoteNames)
                        .forEach((label) => tempName = [...tempName, `${label},`]);
                    tempName[tempName.length - 1] = ')';
                    this._name = tempName.join('');
                    break;
                case (1):
                    const extensionNoteName = labels[0];
                    this._name += ['#', 'b'].includes(extensionNoteName.charAt(0)) ? `add(${extensionNoteName})` : `add${extensionNoteName}`;
                    break;
            }
        }
    }
    handleExtensionNotes(isMajorChord, isPowerChord = false, isDiminished = false) {
        const { MINOR_SECOND, MAJOR_SECOND, MINOR_THIRD, PERFECT_FOURTH, TRITONE, MINOR_SIXTH, MAJOR_SIXTH, MINOR_SEVENTH, MAJOR_SEVENTH } = Interval;
        const nameLookup = new Map([
            [MINOR_SEVENTH, { value: 7, name: '7' }],
            [MAJOR_SEVENTH, { value: 7, name: 'maj7' }],
            [MINOR_SECOND, { value: 9, name: 'b9' }],
            [MAJOR_SECOND, { value: 9, name: '9' }],
            [MINOR_THIRD, { value: 9, name: '#9' }],
            [PERFECT_FOURTH, { value: 11, name: '11' }],
            [TRITONE, { value: 11, name: '#11' }],
            [MINOR_SIXTH, { value: 13, name: 'b13' }],
            [MAJOR_SIXTH, isDiminished ? { value: 7, name: '7' } : { value: 13, name: '13' }]
        ]);
        const extensionNotes = new Map([
            [7, []],
            [9, []],
            [11, []],
            [13, []]
        ]);
        this._intervals.forEach((interval) => {
            if (interval === MINOR_THIRD && !isMajorChord)
                return;
            const pair = nameLookup.get(interval);
            if (pair !== undefined) {
                const { value, name } = pair;
                const intervalToAdd = value;
                const currentIntervals = extensionNotes.get(intervalToAdd) ?? [];
                extensionNotes.set(intervalToAdd, [...currentIntervals, name]);
            }
        });
        if (Array.from(extensionNotes.values()).some((label) => label.length > 0) === false)
            return;
        const sevenths = extensionNotes.get(7) ?? [];
        extensionNotes.delete(7);
        if (sevenths.length !== 0) {
            this._prob += 0.05;
            if (isPowerChord)
                this._name += 'add';
            if (sevenths.length === 2) {
                this._name += '(7, maj7)';
                this.fillExtensionNotes(extensionNotes);
                return;
            }
            while (extensionNotes.size > 0) {
                const lowestInterval = Math.min(...extensionNotes.keys());
                const nextLowestIntervalLabels = extensionNotes.get(lowestInterval) ?? [];
                extensionNotes.delete(lowestInterval);
                if (nextLowestIntervalLabels.length === 0)
                    continue;
                if (sevenths[0] === 'maj7')
                    this._name += 'maj';
                switch (nextLowestIntervalLabels.length) {
                    case (3):
                    case (2):
                        let tempName = ['('];
                        nextLowestIntervalLabels
                            .sort(this.sortNoteNames)
                            .forEach((label) => { tempName = [...tempName, `${label},`]; });
                        tempName[tempName.length - 1] = ')';
                        this._name = tempName.toString();
                        break;
                    case (1):
                        let noteName = nextLowestIntervalLabels[0];
                        noteName = ['#', 'b'].includes(noteName.charAt(0)) ? `(${noteName})` : noteName;
                        this._name += isPowerChord ? ['(', ...noteName, ')'].join('') : noteName;
                        break;
                }
                this.fillExtensionNotes(extensionNotes);
                return;
            }
            this._name += (!isMajorChord && !isDiminished && this._intervals.has(MINOR_THIRD) && sevenths[0] === 'maj7') || isPowerChord ? '(maj7)' : sevenths[0];
            return;
        }
        const sixths = extensionNotes.get(13) ?? [];
        extensionNotes.delete(13);
        if (sixths.length !== 0) {
            if (isPowerChord)
                this._name += 'add';
            switch (sixths.length) {
                case (2):
                    this._name += '(min6, 6)';
                    break;
                case (1):
                    this._name += sixths[0] === 'b13' ? '(min6)' : '6';
                    break;
            }
            this.fillExtensionNotes(extensionNotes);
            return;
        }
        this.fillExtensionNotes(extensionNotes);
    }
    handleSuspendedNotes() {
        const { MINOR_SECOND, MAJOR_SECOND, PERFECT_FOURTH, TRITONE, } = Interval;
        let susTwo = false;
        let susFour = false;
        if (this._intervals.has(MAJOR_SECOND)) {
            susTwo = MAJOR_SECOND;
            this._intervals.delete(MAJOR_SECOND);
        }
        else if (this._intervals.has(MINOR_SECOND)) {
            susTwo = MINOR_SECOND;
            this._intervals.delete(MINOR_SECOND);
        }
        if (this._intervals.has(PERFECT_FOURTH)) {
            susFour = PERFECT_FOURTH;
            this._intervals.delete(PERFECT_FOURTH);
        }
        else if (this._intervals.has(TRITONE)) {
            susFour = TRITONE;
            this._intervals.delete(TRITONE);
        }
        this.handleExtensionNotes(false);
        !!susTwo && this._intervals.add(susTwo);
        !!susFour && this._intervals.add(susFour);
        if (this._intervals.has(MINOR_SECOND) || this._intervals.has(MAJOR_SECOND)) {
            this._name += this._intervals.has(MINOR_SECOND) ? 'sus(b2)' : 'sus2';
        }
        if (this._intervals.has(PERFECT_FOURTH) || this._intervals.has(TRITONE)) {
            this._name += this._intervals.has(TRITONE) ? 'sus(#4)' : 'sus4';
        }
    }
    handleTriad() {
        const { MINOR_THIRD, MAJOR_THIRD } = Interval;
        this._prob = 4;
        if (this._intervals.has(MINOR_THIRD) && !this._intervals.has(MAJOR_THIRD))
            this._name += 'm';
        this.handleExtensionNotes(this._intervals.has(MAJOR_THIRD));
    }
    handleSusOrPowerChord() {
        const { MINOR_SECOND, MAJOR_SECOND, PERFECT_FOURTH, TRITONE, PERFECT_FIFTH } = Interval;
        const hasDimFifth = !this._intervals.has(PERFECT_FIFTH) && this._intervals.has(TRITONE);
        if (hasDimFifth)
            this._intervals.delete(TRITONE);
        const hasSecond = this._intervals.has(MINOR_SECOND) || this._intervals.has(MAJOR_SECOND);
        const hasFourth = this._intervals.has(PERFECT_FOURTH) || this._intervals.has(TRITONE);
        if (hasSecond || hasFourth) {
            this._prob = 3;
            this.handleSuspendedNotes();
        }
        else {
            this._prob = 2;
            this._name += '5';
            this.handleExtensionNotes(false, true);
        }
        if (hasDimFifth) {
            this._prob -= 0.75;
            this._name += '(b5)';
        }
        ;
    }
    handleDyad() {
        const { MINOR_THIRD, MAJOR_THIRD, } = Interval;
        this._prob = 1;
        if (this._intervals.has(MINOR_THIRD))
            this._name += 'm';
        this.handleExtensionNotes(this._intervals.has(MAJOR_THIRD));
        this._name += '(no5)';
    }
    handleDiminished() {
        const { TRITONE, MINOR_SIXTH, MAJOR_SIXTH, MINOR_SEVENTH, MAJOR_SEVENTH } = Interval;
        const dimFifthIsRoot = this._intervals.has(MINOR_SEVENTH) && this._intervals.has(MAJOR_SEVENTH);
        const dimSeventhIsRoot = this._intervals.has(MAJOR_SIXTH) && (this._intervals.has(MINOR_SEVENTH) || this._intervals.has(MAJOR_SEVENTH));
        const minSixthIsRoot = this._intervals.has(MINOR_SIXTH);
        if (dimFifthIsRoot || dimSeventhIsRoot) {
            this._prob = -1;
            return;
        }
        this._prob = minSixthIsRoot ? 3.35 : 4.1;
        this._intervals.delete(TRITONE);
        if (this._intervals.has(MINOR_SEVENTH)) {
            this._name += 'm';
            this.handleExtensionNotes(false, false, true);
            this._name += '(b5)';
        }
        else {
            this._name += '°';
            this.handleExtensionNotes(false, false, true);
        }
    }
    handleAugmented() {
        const { MINOR_SIXTH } = Interval;
        this._prob = 4.1;
        this._intervals.delete(MINOR_SIXTH);
        this._name += '+';
        this.handleExtensionNotes(false);
    }
    determineChordName() {
        const { MINOR_THIRD, MAJOR_THIRD, TRITONE, PERFECT_FIFTH, MINOR_SIXTH } = Interval;
        const hasThird = this._intervals.has(MINOR_THIRD) || this._intervals.has(MAJOR_THIRD);
        const hasFifth = this._intervals.has(PERFECT_FIFTH);
        if (this._name.includes('s')) {
            this._name = this._intervals.has(MINOR_THIRD) && !this._intervals.has(MAJOR_THIRD) ? this._name.replace('s', '#') : Pitch[this._root.pitch + 1] + 'b';
        }
        if (hasFifth && hasThird) {
            this.handleTriad();
        }
        else if (this._intervals.has(MINOR_THIRD) && this._intervals.has(TRITONE) && !this._intervals.has(MAJOR_THIRD)) {
            this.handleDiminished();
        }
        else if (this._intervals.has(MAJOR_THIRD) && this._intervals.has(MINOR_SIXTH)) {
            this.handleAugmented();
        }
        else if (hasFifth || this._intervals.has(TRITONE)) {
            this.handleSusOrPowerChord();
        }
        else if (hasThird) {
            this.handleDyad();
        }
        else {
            this.handleExtensionNotes(false);
            this._name += '(N/C)';
            this._prob = 0;
        }
        if (this._root.pitch !== this._bass.pitch) {
            this._name += '/';
            const bassNoteName = Pitch[this._bass.pitch];
            this._name += bassNoteName.replace('s', '#');
            this._prob -= 0.5;
        }
    }
}
exports.Chord = Chord;
